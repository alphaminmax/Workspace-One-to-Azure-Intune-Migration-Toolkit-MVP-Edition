---
description: 
globs: 
alwaysApply: true
---

# Your rule content

- You can @ files here
- You can use markdown but dont have to

# Cursor AI Prompt for Workspace ONE to Azure Migration Project

```
You're helping me build a production-ready PowerShell-based solution for migrating devices from VMware Workspace ONE to Microsoft Azure/Intune. This migration toolkit needs to handle all aspects of the migration process with enterprise-grade quality. The project follows this structure:

## Project Structure
- src/modules/
  - WorkspaceOneWizard.psm1 (GUI for enrollment)
  - LoggingModule.psm1 (Centralized logging)
- src/scripts/
  - Test-WS1Environment.ps1 (Prerequisite validation)
  - Invoke-WorkspaceOneSetup.ps1 (Main entry point)
  - TestScripts.ps1 (Script validation)
  - Test-MigratedDevice.ps1 (Validates migration success)
  - Remove-WS1Components.ps1 (Cleanup after migration)
- config/
  - WS1Config.json (Configuration settings)
- deployment/
  - Deploy-WS1EnrollmentTools.ps1 (Packaging for deployment)
- tests/
  - Unit/ (Unit test files)
  - Integration/ (Integration test files)

## Key Requirements
1. PRODUCTION QUALITY: This code must be enterprise-grade with:
   - Comprehensive error handling with try/catch and rollback
   - Extensive input validation and parameter validation
   - Secure credential handling (integrate with Key Vault if possible)
   - Detailed logging with configurable verbosity
   - Thorough documentation with comment-based help

2. VALIDATION FOCUS: Create robust validation mechanisms:
   - Parameter validation in all functions (ValidateSet, ValidatePattern)
   - Environment validation before migration
   - Post-migration validation to verify success
   - Script syntax and initialization validation

3. ERROR HANDLING: Implement resilient error management:
   - Structured try/catch with specific error codes
   - Transaction-based operations with rollback capability
   - Recovery mechanisms for common failure scenarios
   - Clean error messages for administrators

4. SECURITY: Follow security best practices:
   - Code signing support
   - Secure credential handling (no plaintext)
   - Role-based access controls
   - Least-privilege execution model
   - Audit logging for sensitive operations

5. TESTING: Create testable code with:
   - Unit tests for all functions
   - Integration tests for workflows
   - Mocking capabilities for testing

When helping me write a specific component, please:
1. First ask me which component we're working on
2. Provide a detailed, production-ready implementation
3. Include error handling, logging, and validation
4. Add comprehensive comment-based help
5. Consider edge cases and error scenarios
6. Suggest unit tests for the component

Approach all code as if it's going into a mission-critical enterprise environment where reliability and security are paramount.
```

This prompt gives your Cursor AI a comprehensive understanding of your migration project and what you expect in terms of code quality. It emphasizes the production readiness aspects we discussed, focusing on validation, error handling, security, and testing.

When you use this prompt, Cursor will be primed to help you implement specific components of your migration toolkit with enterprise-grade quality. You can then follow up with specific requests like "Help me implement the Test-MigratedDevice.ps1 script" or "Let's create a robust logging module," and Cursor will be prepared to deliver high-quality, production-ready code.
